const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

// Initialize Supabase client
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('ERROR: SUPABASE_URL and SUPABASE_ANON_KEY must be set in .env file');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

// Database wrapper to provide SQLite-like interface
const db = {
  supabase: supabase,
  
  // Run a query (INSERT, UPDATE, DELETE)
  run: async function(sql, params = [], callback) {
    try {
      const result = await executeQuery(sql, params);
      if (callback) {
        callback.call({ lastID: result.lastID, changes: result.changes }, null);
      }
      return result;
    } catch (error) {
      console.error('Database run error:', error);
      if (callback) {
        callback.call({}, error);
      }
      throw error;
    }
  },
  
  // Get a single row
  get: async function(sql, params = [], callback) {
    try {
      const result = await executeQuery(sql, params);
      const row = result.rows && result.rows.length > 0 ? result.rows[0] : null;
      if (callback) {
        callback(null, row);
      }
      return row;
    } catch (error) {
      console.error('Database get error:', error);
      if (callback) {
        callback(error, null);
      }
      throw error;
    }
  },
  
  // Get all rows
  all: async function(sql, params = [], callback) {
    try {
      const result = await executeQuery(sql, params);
      const rows = result.rows || [];
      if (callback) {
        callback(null, rows);
      }
      return rows;
    } catch (error) {
      console.error('Database all error:', error);
      if (callback) {
        callback(error, []);
      }
      throw error;
    }
  }
};

// Helper function to execute queries
async function executeQuery(sql, params = []) {
  const sqlLower = sql.toLowerCase().trim();
  
  // Parse SQL to determine operation type
  if (sqlLower.startsWith('select')) {
    return await executeSelect(sql, params);
  } else if (sqlLower.startsWith('insert')) {
    return await executeInsert(sql, params);
  } else if (sqlLower.startsWith('update')) {
    return await executeUpdate(sql, params);
  } else if (sqlLower.startsWith('delete')) {
    return await executeDelete(sql, params);
  } else if (sqlLower.includes('create table') || sqlLower.includes('alter table') || sqlLower.includes('pragma')) {
    // Skip schema operations - these should be run in Supabase SQL editor
    return { rows: [], changes: 0 };
  }
  
  throw new Error(`Unsupported SQL operation: ${sql.substring(0, 50)}`);
}

// Helper function to execute queries
async function executeQuery(sql, params = []) {
  const sqlLower = sql.toLowerCase().trim();
  
  // Parse SQL to determine operation type
  if (sqlLower.startsWith('select')) {
    return await executeSelect(sql, params);
  } else if (sqlLower.startsWith('insert')) {
    return await executeInsert(sql, params);
  } else if (sqlLower.startsWith('update')) {
    return await executeUpdate(sql, params);
  } else if (sqlLower.startsWith('delete')) {
    return await executeDelete(sql, params);
  } else if (sqlLower.includes('create table') || sqlLower.includes('alter table') || sqlLower.includes('pragma')) {
    // Skip schema operations - these should be run in Supabase SQL editor
    return { rows: [], changes: 0 };
  }
  
  throw new Error(`Unsupported SQL operation: ${sql.substring(0, 50)}`);
}

// Parse table name from SQL
function parseTableName(sql) {
  const sqlLower = sql.toLowerCase();
  
  if (sqlLower.includes('from')) {
    const match = sql.match(/from\s+([a-z_]+)/i);
    if (match) return match[1];
  }
  
  if (sqlLower.includes('into')) {
    const match = sql.match(/into\s+([a-z_]+)/i);
    if (match) return match[1];
  }
  
  if (sqlLower.includes('update')) {
    const match = sql.match(/update\s+([a-z_]+)/i);
    if (match) return match[1];
  }
  
  if (sqlLower.includes('delete from')) {
    const match = sql.match(/delete\s+from\s+([a-z_]+)/i);
    if (match) return match[1];
  }
  
  return null;
}

// Execute SELECT queries
async function executeSelect(sql, params) {
  // Replace ? with $1, $2, etc. for PostgreSQL
  let pgSql = sql;
  params.forEach((_, index) => {
    pgSql = pgSql.replace('?', `$${index + 1}`);
  });
  
  const { data, error } = await supabase.rpc('execute_sql', {
    query: pgSql,
    params: params
  });
  
  if (error) {
    // Fallback to direct table queries if RPC fails
    return await executeSelectDirect(sql, params);
  }
  
  return { rows: data || [] };
}

// Direct SELECT execution using Supabase query builder
async function executeSelectDirect(sql, params) {
  const tableName = parseTableName(sql);
  if (!tableName) {
    throw new Error('Could not parse table name from SQL');
  }
  
  let query = supabase.from(tableName).select('*');
  
  // Apply WHERE conditions if params exist
  if (params.length > 0 && sql.includes('WHERE id = ?')) {
    query = query.eq('id', params[0]);
  }
  
  const { data, error } = await query;
  
  if (error) {
    throw error;
  }
  
  return { rows: data || [] };
}

// Execute INSERT queries
async function executeInsert(sql, params) {
  const tableName = parseTableName(sql);
  if (!tableName) {
    throw new Error('Could not parse table name from INSERT');
  }
  
  // Parse column names from INSERT statement
  const columnsMatch = sql.match(/\(([^)]+)\)/);
  if (!columnsMatch) {
    throw new Error('Could not parse columns from INSERT');
  }
  
  const columns = columnsMatch[1].split(',').map(c => c.trim());
  const insertData = {};
  
  columns.forEach((col, index) => {
    if (params[index] !== undefined) {
      insertData[col] = params[index];
    }
  });
  
  const { data, error } = await supabase
    .from(tableName)
    .insert(insertData)
    .select();
  
  if (error) {
    throw error;
  }
  
  return {
    lastID: data && data.length > 0 ? data[0].id : null,
    changes: data ? data.length : 0,
    rows: data
  };
}

// Execute UPDATE queries
async function executeUpdate(sql, params) {
  const tableName = parseTableName(sql);
  if (!tableName) {
    throw new Error('Could not parse table name from UPDATE');
  }
  
  // Parse SET clause
  const setMatch = sql.match(/SET\s+(.+?)\s+WHERE/i);
  if (!setMatch) {
    throw new Error('Could not parse SET clause from UPDATE');
  }
  
  const setParts = setMatch[1].split(',').map(s => s.trim());
  const updateData = {};
  let paramIndex = 0;
  
  setParts.forEach(part => {
    const [column] = part.split('=').map(p => p.trim());
    if (params[paramIndex] !== undefined) {
      updateData[column] = params[paramIndex++];
    }
  });
  
  // Parse WHERE clause
  let query = supabase.from(tableName).update(updateData);
  
  if (sql.includes('WHERE id = ?') && params[paramIndex] !== undefined) {
    query = query.eq('id', params[paramIndex]);
  }
  
  const { data, error } = await query.select();
  
  if (error) {
    throw error;
  }
  
  return {
    changes: data ? data.length : 0,
    rows: data
  };
}

// Execute DELETE queries
async function executeDelete(sql, params) {
  const tableName = parseTableName(sql);
  if (!tableName) {
    throw new Error('Could not parse table name from DELETE');
  }
  
  let query = supabase.from(tableName).delete();
  
  if (sql.includes('WHERE id = ?') && params.length > 0) {
    query = query.eq('id', params[0]);
  } else if (sql.includes('WHERE event_id = ?') && params.length > 0) {
    query = query.eq('event_id', params[0]);
  } else if (sql.includes('WHERE competitor_id = ?') && params.length > 0) {
    query = query.eq('competitor_id', params[0]);
  }
  
  const { data, error } = await query.select();
  
  if (error) {
    throw error;
  }
  
  return {
    changes: data ? data.length : 0,
    rows: data
  };
}

console.log('Supabase database client initialized successfully');

module.exports = db;
